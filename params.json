{"tagline":"Yet another event handler","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Yeah","body":"# Yeah\r\nYet another event handler (AKA Sub/Pub).  What seperates Yeah from other Sub/Pub helpers is it provides two key features to help deal with event heavy applications; Compound events and Latched events.  \r\n\r\n#### Examples:\r\n- [Extending Objects](#extending-objects)\r\n- [Using As A Global Mediator](#using-as-a-global-mediator)\r\n- [Latched events at a glance](#latched-events-at-a-glance)\r\n\r\n#### Methods:\r\n- [addEvent](#addevent)\r\n- [addEvents](#addevents)\r\n- [removeEvent](#removeevent)\r\n- [fireEvent](#fireevent)\r\n- [hasFired](#hasfired)\r\n- [getEvents](#getevents)\r\n- [callMeMaybe](#callmemaybe)\r\n\r\n\r\n## Examples:\r\n\r\n#### Extending objects\r\nThere's a few ways you can mix Yeah's functionality into your application.\r\n\r\n```js \r\nvar yeah = require('yeah')\r\nvar APP = yeah({\r\n\tinitialize: function (what, options) {\r\n\t\toptions = options || {}\r\n\t\tthis.addEvents(options.events)\r\n\t\tthis.fireEvent('hello', what)\r\n\t}\r\n})\r\n\r\nAPP.initialize('World', {\r\n\tevents: {\r\n\t\thello: function (what) {\r\n\t\t\talert('Hello '+ what)\r\n\t\t}\r\n\t}\r\n})\r\n\r\n// ==========================\r\n// Use as a standard constructor\r\nvar yeah = require('yeah')\r\nvar APP = new yeah()\r\n\r\n// ==========================\r\n// Request the `mixin` object to use as a standard mixin\r\nvar EventsMixin = require('yeah/mixin')\r\nvar APP = {}\r\nextend(APP, EventsMixin)\r\n```\r\n\r\n#### Using As A Global Mediator\r\nThis example show's yeah being used as a global mediator.  We're utilizing  compound events to detect when the app can initialize (after the FB object is available & the DOM is ready).\r\n\r\n```js\r\nvar Mediator = require('yeah')\r\nvar APP = require('app')\r\n\r\n// Handle the FB SDK\r\nfbAsyncInit = function() {\r\n\tMediator.fireEvent('FB.ready:latched',FB)\r\n}\r\n\r\n// When we need to access the FB object,\r\n// we can simply reference it via the Mediator\r\n// this way we know it will be available\r\nMediator.addEvent('FB.ready', function (fb) {\r\n\tfb.init({\r\n    appId      : 'YOUR_APP_ID',\r\n    channelUrl : '//WWW.YOUR_DOMAIN.COM/channel.html', \r\n    status     : true,\r\n    cookie     : true,\r\n    xfbml      : true\r\n  })\r\n})\r\n\r\n// Notify the mediator when the DOM is ready\r\n// This can now be used like $(document).ready\r\naddEventListener('DOMContentLoaded', Mediator.callMeMaybe('DOM.ready:latched'))\r\n\r\n// the event 'APP.env.ready' will fire once\r\n// the FB sdk has been initialized and the \r\n// DOM is ready.\r\nMediator.addEvent(['DOM.ready','FB.ready'], 'APP.env.ready', function () {\r\n\tAPP.init()\r\n\t// This is safe because the DOMContentLoaded event has already fired\r\n\tAPP.inject(document.body)\r\n})\r\n\r\n```\r\n\r\n#### Latched events at a glance\r\n```js\r\nvar yeah = require('yeah')\r\nvar APP = yeah({\r\n     i: 0\r\n    ,initialize: function () {\r\n        this.fireEvent('tick:latched')\r\n        console.log('---- Initialized ----')\r\n    }\r\n    ,increment: function () {\r\n        this.i++\r\n        console.log(this.i)\r\n    }\r\n})\r\n\r\n// Queue up the `tick` stack with 5 events\r\nfor (var i = 1; i <= 5;i++) {\r\n    // the functions need to be unique.\r\n    // so we can't do addEvent('tick',APP.increment)\r\n    APP.addEvent('tick', function () {\r\n        APP.increment()\r\n    })\r\n}\r\n\r\n// this will fire 'tick', logging 1-5\r\nAPP.initialize()\r\n\r\n// Here's some timers simulating the apps duration\r\n// We'll add 5 more events to `tick` after it's been fired\r\nvar interval = setInterval(function () {\r\n    APP.addEvent('tick',APP.increment)\r\n    if (APP.i == 10) {\r\n        clearInterval(interval)\r\n    }\r\n}, 200)​\r\n```\r\n\r\n\r\n## Methods\r\n\r\n===\r\n### #addEvent\r\n\r\n#### Arguments:\r\n###### __Standard__ \r\n1. *{string}*  __name__ : The name of the event stack  \r\n2. *{function}* __event__ : Unique event to be added to the __event stack__  \r\n\r\n ```js\r\n addEvent( 'name', fn )\r\n ```  \r\n\t\r\n###### __Add Event List__   \r\n1. *{string}* __name__ : The name of the event stack  \r\n2. *{array}* __stack__ : A list of functions to add to the __event stack__  \r\n\r\n```js\r\naddEvent( 'name', [fn1, fn2 /*, …*/] )\r\n```    \r\n\r\n###### __Create Compound Event__ \r\n1. *{array}* __names__ : A list of event's that need to be fired before the compound event can fire.  \r\n_*NOTE*: these will all be fired as [:latched](#latched-events)._ \r\n2. *{string}* __name__ : The compound event's name\r\n3. *{function}* __event__ (optional): The event to be added to the compound event's __event stack__\r\n\r\n\r\n```js\r\naddEvent( ['dom.ready','template.ready'], 'everythings.ready', fn )\r\n```\r\n\r\n#### Examples:\r\n```js\r\nvar EventsMixin = require('yeah/mixin')\r\nvar mediator = extend({}, EventsMixin)\r\n \r\n// add an event to an event key\r\nmediator.addEvent('something', fn)\r\n// add an array of events to one event key\r\nmediator.addEvent('something', [\r\n  function () {}, function () {}\r\n])\r\n\r\n// compound events: when 2+ events are fired, fire another\r\nmediator.addEvent(['something','anotherthing'],'both.things', function oneThing() {})\r\n// add more events to the compound event\r\nmediator.addEvent('both.things', function letsAddAnother () {})\r\n```\r\n\r\n===\r\n### #addEvents\r\n\r\nA convenience method for adding multiple event stacks at a time.\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{object}* __hash__ : key/value object where `key` is the event name, and `value` is a function or array of functions  \r\n\r\n```js\r\ninstance.addEvents({key: fn, anotherKey: anotherFn })\r\n```\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvents({\r\n\t'model.ready': function (model) {\r\n\t\tmodel.get('/path', function (response) {\r\n\t\t\tinstance.fireEvent('data.got', response.text)\r\n\t\t})\r\n\t},\r\n\t'data.got': [\r\n\t\tfunction (text) {\r\n\t\t\tif (text.indexOf('dog')) {\r\n\t\t\t\t// do something for dogs\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction (text) {\r\n\t\t\tif (text.indexOf('cat')) {\r\n\t\t\t\t// do something for cats\r\n\t\t\t}\r\n\t\t}\r\n\t]\r\n})\r\n```\r\n\r\n===\r\n### #removeEvent\r\n\r\n#### Arguments:\r\n\r\n###### __Standard__\r\n\r\n1. *{string}* __name__ : the event stack identifier\r\n2. *{function}* __event__ : a reference of the function to remove\r\n\r\n#### Example:\r\n```js\r\nfunction doThis () {\r\n\tconsole.log('lol')\r\n}\r\n\r\ninstance.addEvent('on.lol', doThis)\r\ninstance.fireEvent('on.lol') // logs: 'lol'\r\ninstance.removeEvent('on.lol', doThis)\r\ninstance.fireEvent('on.lol') // nothing happens\r\n```\r\n\r\n\r\n===\r\n### #fireEvent\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : The event stack identifer\r\n2. *{arguments}* __arguments__ (optional) : Every subsequent argument will be passed into  the fired events\r\n\r\n```js\r\ninstance.fireEvent('name'  /*, arg1, arg2, … */)\r\n```\r\n\r\n###### Latched Events\r\n1. *{string}* '__name__' + ':latched' : An event stack identifier with a concatenated `:latched` \r\n2. *{arguments}* __arguments__ : The arguments work the same as with the standard firing\r\n\r\nA latched event is one that once fired, remains active for the remainder of the application. Once fired,   Subsequent attempts to add a function to a latched event's event stack will result in the function being fired immedatly. \r\n\r\nAn example of a native \"latched\" event would be the `DOMContentLoaded` event. Once the DOM Content has loaded, it will forever be loaded. \r\n\r\n```js\r\ninstance.fireEvent('name:latched'  /*, arg1, arg2, …*/)\r\n```\r\n\r\n#### Example:\r\n```js\r\nvar EventMixin = require('yeah/mixin')\r\nvar instance = extend({}, EventMixin)\r\nvar wachooSay = []\r\n\r\nfunction say (what) {\r\n\talert(what)\r\n}\r\n\r\ninstance.addEvent('say.hello', [\r\n\tfunction () {wachooSay = []},\r\n\tfunction () {wachooSay.push(\"Hello\")},\r\n\tfunction () {wachooSay.concat(Array.prototype.slice.call(arguments)) },\r\n\tfunction () { say(wachooSay.join(' ')) }\r\n])\r\n\r\n// Firing with the standard method\r\ninstance.fireEvent('say.hello', \"Jiggliemon\") // will alert `Hello Jiggliemon`\r\ninstance.fireEvent('say.hello', \"Friends\") // will alert `Hello Friends`\r\n\r\n// Firing with the `:latched` identifier\r\ninstance.fireEvent('say.hello:latched', \"Visitor\", \":)\") // will alert `Hello Visitor :)`\r\ninstance.fireEvent('say.hello', \"Goodbye\") \r\ninstance.addEvent('say.hello', function () {\r\n\talert('Simple Hello')\r\n}) // will alert `Simple Hello` immediatly\r\n```\r\n\r\n===\r\n### #hasFired\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : Event stack identifer\r\n\r\n```js\r\ninstance.hasFired('name')\r\n```\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvent('smile', function () {\r\n\talert(':)')\r\n})\r\ninstance.hasFired('smile') // false\r\ninstance.fireEvent('smile') // alerts `smile\r\ninstance.hasFired('smile') // true\r\n```\r\n===\r\n### #getEvents\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : Event stack identifer\r\n\r\n```js\r\ninstance.getEvents('name')\r\n```\r\n\r\n#### Example:\r\n```js\r\nvar fn = function () {\r\n\talert(':)')\r\n}\r\ninstance.addEvent('smile',fn)\r\n\r\ninstance.getEvents('smile') // false\r\ninstance.getEvents('smile') // [fn] returns an array of the functions in the event stack\r\n```\r\n\r\n===\r\n### #callMeMaybe\r\nReturns a function that will fire a specified event stack when called.\r\n\r\n#### Arguments:\r\n_same as [#fireEvent](#fireevent)_\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvent('hello', function (arg) {\r\n\tconsole.log('Hello' + ' ' + arg)\r\n})\r\nvar latered = instance.callMeMaybe('hello', 'Chase') // Not fired yet\r\nlatered() // logs: Hello Chase\r\n```\r\n\r\n\r\n","google":"UA-30450217-2"}