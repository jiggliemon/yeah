{"tagline":"Yet another event handler","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Yeah","body":"# Yeah\r\nYet another event handler\r\n\r\n## Examples:\r\n\r\n```js\r\nvar Mediator = require('yeah')\r\nvar APP = require('app')\r\n\r\n// Handle the FB SDK\r\nfbAsyncInit = function() {\r\n\tMediator.fireEvent('FB.ready:latched',FB)\r\n}\r\n\r\n// When we need to access the FB object,\r\n// we can simply reference it via the Mediator\r\n// this way we know it will be available\r\nMediator.addEvent('FB.ready', function (fb) {\r\n\tfb.init({\r\n    appId      : 'YOUR_APP_ID',\r\n    channelUrl : '//WWW.YOUR_DOMAIN.COM/channel.html', \r\n    status     : true,\r\n    cookie     : true,\r\n    xfbml      : true\r\n  })\r\n})\r\n\r\n// Notify the mediator when the DOM is ready\r\n// This can now be used like $(document).ready\r\naddEventListener('DOMContentLoaded', Mediator.callMeMaybe('DOM.ready:latched'))\r\n\r\n// the event 'APP.env.ready' will fire once\r\n// the FB sdk has been initialized and the \r\n// DOM is ready.\r\nMediator.addEvent(['DOM.ready','FB.ready'], 'APP.env.ready', function () {\r\n\tAPP.init()\r\n\t// This is safe because the DOMContentLoaded event has already fired\r\n\tAPP.inject(document.body)\r\n})\r\n\r\n```\r\n\r\n## Mixin API\r\n\r\n#### Methods:\r\n- [addEvent](#addevent)\r\n- [addEvents](#addevents)\r\n- [removeEvent](#removeevent)\r\n- [fireEvent](#fireevent)\r\n- [hasFired](#hasfired)\r\n- [getEvents](#getevents)\r\n- [callMeMaybe](#callmemaybe)\r\n\r\n#### Example:\r\n```js\r\nvar EventMixin = require('yeah/mixin')\r\nvar mediator = extend({}, EventMixin)\r\n```\r\n\r\n===\r\n### #addEvent\r\n\r\n#### Arguments:\r\n###### __Standard__ \r\n1. *{string}*  __name__ : The name of the event stack  \r\n2. *{function}* __event__ : Unique event to be added to the __event stack__  \r\n\r\n ```js\r\n addEvent( 'name', fn )\r\n ```  \r\n\t\r\n###### __Add Event List__   \r\n1. *{string}* __name__ : The name of the event stack  \r\n2. *{array}* __stack__ : A list of functions to add to the __event stack__  \r\n\r\n```js\r\naddEvent( 'name', [fn1, fn2 /*, …*/] )\r\n```    \r\n\r\n###### __Create Compound Event__ \r\n1. *{array}* __names__ : A list of event's that need to be fired before the compound event can fire  \r\n2. *{string}* __name__ : The compound event's name  \r\n3. *{function}* __event__ (optional): The event to be added to the compound event's __event stack__\r\n\r\n```js\r\naddEvent( ['dom.ready','template.ready'], 'everythings.ready', fn )\r\n```\r\n\r\n#### Examples:\r\n```js\r\nvar EventsMixin = require('yeah/mixin')\r\nvar mediator = extend({}, EventsMixin)\r\n \r\n// add an event to an event key\r\nmediator.addEvent('something', fn)\r\n// add an array of events to one event key\r\nmediator.addEvent('something', [\r\n  function () {}, function () {}\r\n])\r\n\r\n// compound events: when 2+ events are fired, fire another\r\nmediator.addEvent(['something','anotherthing'],'both.things', function oneThing() {})\r\n// add more events to the compound event\r\nmediator.addEvent('both.things', function letsAddAnother () {})\r\n```\r\n\r\n===\r\n### #addEvents\r\n\r\nA convenience method for adding multiple event stacks at a time.\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{object}* __hash__ : key/value object where `key` is the event name, and `value` is a function or array of functions  \r\n\r\n```js\r\ninstance.addEvents({key: fn, anotherKey: anotherFn })\r\n```\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvents({\r\n\t'model.ready': function (model) {\r\n\t\tmodel.get('/path', function (response) {\r\n\t\t\tinstance.fireEvent('data.got', response.text)\r\n\t\t})\r\n\t},\r\n\t'data.got': [\r\n\t\tfunction (text) {\r\n\t\t\tif (text.indexOf('dog')) {\r\n\t\t\t\t// do something for dogs\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction (text) {\r\n\t\t\tif (text.indexOf('cat')) {\r\n\t\t\t\t// do something for cats\r\n\t\t\t}\r\n\t\t}\r\n\t]\r\n})\r\n```\r\n\r\n===\r\n### #removeEvent\r\n\r\n#### Arguments:\r\n\r\n###### __Standard__\r\n\r\n1. *{string}* __name__ : the event stack identifier\r\n2. *{function}* __event__ : a reference of the function to remove\r\n\r\n#### Example:\r\n```js\r\nfunction doThis () {\r\n\tconsole.log('lol')\r\n}\r\n\r\ninstance.addEvent('on.lol', doThis)\r\ninstance.fireEvent('on.lol') // logs: 'lol'\r\ninstance.removeEvent('on.lol', doThis)\r\ninstance.fireEvent('on.lol') // nothing happens\r\n```\r\n\r\n\r\n===\r\n### #fireEvent\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : The event stack identifer\r\n2. *{arguments}* __arguments__ (optional) : Every subsequent argument will be passed into  the fired events\r\n\r\n```js\r\ninstance.fireEvent('name'  /*, arg1, arg2, … */)\r\n```\r\n\r\n###### Latched Events\r\n1. *{string}* '__name__' + ':latched' : An event stack identifier with a concatenated `:latched` \r\n2. *{arguments}* __arguments__ : The arguments work the same as with the standard firing\r\n\r\nA latched event is one that once fired, remains active for the remainder of the application. Once fired,   Subsequent attempts to add a function to a latched event's event stack will result in the function being fired immedatly. \r\n\r\nAn example of a native \"latched\" event would be the `DOMContentLoaded` event. Once the DOM Content has loaded, it will forever be loaded. \r\n\r\n```js\r\ninstance.fireEvent('name:latched'  /*, arg1, arg2, …*/)\r\n```\r\n\r\n#### Example:\r\n```js\r\nvar EventMixin = require('yeah/mixin')\r\nvar instance = extend({}, EventMixin)\r\nvar wachooSay = []\r\n\r\nfunction say (what) {\r\n\talert(what)\r\n}\r\n\r\ninstance.addEvent('say.hello', [\r\n\tfunction () {wachooSay = []},\r\n\tfunction () {wachooSay.push(\"Hello\")},\r\n\tfunction () {wachooSay.concat(Array.prototype.slice.call(arguments)) },\r\n\tfunction () { say(wachooSay.join(' ')) }\r\n])\r\n\r\n// Firing with the standard method\r\ninstance.fireEvent('say.hello', \"Jiggliemon\") // will alert `Hello Jiggliemon`\r\ninstance.fireEvent('say.hello', \"Friends\") // will alert `Hello Friends`\r\n\r\n// Firing with the `:latched` identifier\r\ninstance.fireEvent('say.hello:latched', \"Visitor\", \":)\") // will alert `Hello Visitor :)`\r\ninstance.fireEvent('say.hello', \"Goodbye\") \r\ninstance.addEvent('say.hello', function () {\r\n\talert('Simple Hello')\r\n}) // will alert `Simple Hello` immediatly\r\n```\r\n\r\n===\r\n### #hasFired\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : Event stack identifer\r\n\r\n```js\r\ninstance.hasFired('name')\r\n```\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvent('smile', function () {\r\n\talert(':)')\r\n})\r\ninstance.hasFired('smile') // false\r\ninstance.fireEvent('smile') // alerts `smile\r\ninstance.hasFired('smile') // true\r\n```\r\n===\r\n### #getEvents\r\n\r\n#### Arguments:\r\n###### __Standard__\r\n1. *{string}* __name__ : Event stack identifer\r\n\r\n```js\r\ninstance.getEvents('name')\r\n```\r\n\r\n#### Example:\r\n```js\r\nvar fn = function () {\r\n\talert(':)')\r\n}\r\ninstance.addEvent('smile',fn)\r\n\r\ninstance.getEvents('smile') // false\r\ninstance.getEvents('smile') // [fn] returns an array of the functions in the event stack\r\n```\r\n\r\n===\r\n### #callMeMaybe\r\nReturns a function that will fire a specified event stack when called.\r\n\r\n#### Arguments:\r\n_same as [#fireEvent](#fireevent)_\r\n\r\n#### Example:\r\n```js\r\ninstance.addEvent('hello', function (arg) {\r\n\tconsole.log('Hello' + ' ' + arg)\r\n})\r\nvar latered = instance.callMeMaybe('hello', 'Chase') // Not fired yet\r\nlatered() // logs: Hello Chase\r\n```\r\n\r\n\r\n","google":""}